# 메모리 할당과 해제
## 프로그램 메모리 관리
* GC 사용하는 언어들 - Java, Go, Python, JS
* 수동 관리 - C, C++
* 컴파일 시점에 메모리 관리 규칙 검사 - Rust

## GC 활용 방식
* 대부분 현대 언어에서 활용
* 실행 시간 중에 때때로 쓰지 않는 메모리 정리
* 개발하기 편하다
* 운영할때 성능상 문제가 된다.

## 수동 메모리 관리
* C, C++
* 개발자가 메모리 할당 / 해제 작업 지시
* 최적의 속도 실행시 메모리 관리 부담 최소
* 개발하기 힘들다

## 러스트의 메모리 관리 - 소유권
* 소유권 규칙에 따라 컴파일 시점에 메모리 할당 / 해제
* 규칙에 어긋나면 컴파일 되지 않음
* 규칙을 잘 지키면 컴파일러가 잘 처리
* 실행시간 손해 없으면서도, 실수 방지

## 변수의 범위 scope 가 끝나면 메모리 헤제 가능하다
* 블록 안에서 변수가 유효, 블록 벗어나면 무효
``` rust
fn main() {
	{
		let s = "헬로";
		println!("s : {}", s); // 유효
	}
	println!("s : {}", s); // 무효 컴파일 안됨
}
```
## 스택과 힙 메모리 stack and heap
 * 보통 언어에서는 구분해 생각할 필요 없지만 알면 좋은정도
 * 러스트에서는 초반에 잘 알아두고 넘어가야 좋다

####  문자열 리터럴과 String
* 기본 데이터 타입은 Stack 에서 쉽게 관리 가능 // 크기 고정이기 때문
* 문자열 리터럴 String literal 은 프로그램에 "고정" 으로 확보
* 문자열 리터럴은 불변 immutable
* 사용자가 입력하는 문자열은 어떻게..? (미리 크기 알 수 없다.)

#### 문자열 String type
* 변경 가능 mutable - 길이가 늘어날 수도 있다.
* 따라서, 컴파일 시점에 크기를 알 수 없음
* 그러니 heap 메모리에 차지해야함

#### 문자열 타입 메모리 할당
``` rust
fn main() {
	let mut s: String = String::from("헬로");
	s.push_str(", 월드!");
	println!("s = {}", s);
}
```
* 실행 시점에 메모리 할당 요청
* 메모리 할당한 문자열 다 쓰고 나면?
* 사용 가능한 메모리로 반환하는 방법 필요하다

## 소유권 규칙
* Rust 에서 모든 값은 소유자(owner)가 있다
* 한 시점에 딱 하나의 소유자가 있을 수 있다.
* 소유자의 범위가 끝나면, 값도 제거된다.

### 러스트는 메모리를 복사하지 않는한 메모리를 복사하지 않고, 공유하면서 씀

### 기본 #데이터타입 은 스택 메모리 안에서 copy 된다.
* 단 튜플 타입은, 안의 모든 요소가 기본 데이터 타입 일 때만.. (ex, String이 Tuple 안에 있을 경우)

## 함수 호출시 소유권 이동
* 함수를 호출할 경우 소유권이 이동되어서, 원래 스택에서는 못부름
``` rust
fn main() {

	let s = String::from("헬로");
	string_length(s);
	// main 함수를 벗어나 s는 더이상 유효하지 않음, 컴파일 에러
	println!("s = {}", s);
}

  

fn string_length(s:String) {
	// s 소유권 이동
	println!("문자열 길이: {}", s.len());
}
```

## 함수 반환 값의 소유권 이동
* 함수 반환 이후에는 소유권이 펑션의 s -> s3로 이동함
``` rust
let s2 = String::from("hello");
let s3 = string_length_return(s2);
println!("s3 : {s3}");


fn string_length_return(s:String) -> String {
	println!("문자열 길이: {}", s.len());
	s
}
```
### 불필요한 소유권 이동을 막기위해 - 소유권 임대 개념

## 소유권 임대
